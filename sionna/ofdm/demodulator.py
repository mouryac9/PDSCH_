#
# SPDX-FileCopyrightText: Copyright (c) 2021-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
"""Class definition for the OFDM Demodulator"""

import tensorflow as tf
from tensorflow.keras.layers import Layer
from tensorflow.signal import fftshift
from sionna.constants import PI
from sionna.utils import expand_to_rank
from sionna.signal import fft
import numpy as np

class OFDMDemodulator(Layer):
    # pylint: disable=line-too-long
    r"""
    OFDMDemodulator(fft_size, l_min, cyclic_prefix_length=0, cyclic_prefix_length_first_symbol=None, symbols_per_block=1, **kwargs)

    Computes the frequency-domain representation of an OFDM waveform
    with cyclic prefix removal.

    When only `cyclic_prefix_length` is given then a cyclic prefix of length
    `cyclic_prefix_length` is removed from each symbol. When additionally
    `cyclic_prefix_length_first_symbol` and `symbols_per_block` are given then
    the length of the cyclic prefix is `cyclic_prefix_length_first_symbol` for
    the first symbol of each block and `cyclic_prefix_length` for the
    remaining symbols. For LTE one block corresponds to one slot (i.e., 7
    symbols). For 5G NR one block corresponds to one half subframe and the
    number of symbols depends on the numerology.

    The demodulator assumes that the input sequence is generated by the
    :class:`~sionna.channel.TimeChannel`. For a single pair of antennas,
    the received signal sequence is given as:

    .. math::

        y_b = \sum_{\ell =L_\text{min}}^{L_\text{max}} \bar{h}_\ell x_{b-\ell} + w_b, \quad b \in[L_\text{min}, N_B+L_\text{max}-1]

    where :math:`\bar{h}_\ell` are the discrete-time channel taps,
    :math:`x_{b}` is the the transmitted signal,
    and :math:`w_\ell` Gaussian noise.

    Starting from the first symbol, the demodulator cuts the input
    sequence into pieces of size ``cyclic_prefix_length + fft_size``,
    and throws away any trailing symbols. For each piece, the cyclic
    prefix is removed and the ``fft_size``-point discrete Fourier
    transform is computed.

    Since the input sequence starts at time :math:`L_\text{min}`,
    the FFT-window has a timing offset of :math:`L_\text{min}` symbols,
    which leads to a subcarrier-dependent phase shift of
    :math:`e^{\frac{j2\pi k L_\text{min}}{N}}`, where :math:`k`
    is the subcarrier index, :math:`N` is the FFT size,
    and :math:`L_\text{min} \le 0` is the largest negative time lag of
    the discrete-time channel impulse response. This phase shift
    is removed in this layer, by explicitly multiplying
    each subcarrier by  :math:`e^{\frac{-j2\pi k L_\text{min}}{N}}`.
    This is a very important step to enable channel estimation with
    sparse pilot patterns that needs to interpolate the channel frequency
    response across subcarriers. It also ensures that the
    channel frequency response `seen` by the time-domain channel
    is close to the :class:`~sionna.channel.OFDMChannel`.

    Parameters
    ----------
    fft_size : int
        FFT size (, i.e., the number of subcarriers).

    l_min : int
        The largest negative time lag of the discrete-time channel
        impulse response. It should be the same value as that used by the
        `cir_to_time_channel` function.

    cyclic_prefix_length : int
        Integer indicating the length of the cyclic prefix that it prepended
        to each OFDM symbol (except for the first symbol of each block if
        `cyclic_prefix_length_first_symbol` and `symbols per block` is given).

    cyclic_prefix_length_first_symbol : int
        Integer indicating the length of the cyclic prefix that it prepended
        to the first OFDM symbol of each block.

    symbols_per_block : int
        Integer indicating the number of symbols per block.

    Input
    -----
    :[...,num_ofdm_symbols*(fft_size+cyclic_prefix_length)+n], tf.complex
        Tensor containing the time-domain signal along the last dimension.
        `n` is a nonnegative integer.

    Output
    ------
    :[...,num_ofdm_symbols,fft_size], tf.complex
        Tensor containing the OFDM resource grid along the last
        two dimension.
    """

    def __init__(self, fft_size, l_min, cyclic_prefix_length=0,
                 cyclic_prefix_length_first_symbol=None, symbols_per_block=1,
                 **kwargs):
        super().__init__(**kwargs)
        self.fft_size = fft_size
        self.l_min = l_min
        self.cyclic_prefix_length = cyclic_prefix_length
        self.cyclic_prefix_length_first_symbol =(
            cyclic_prefix_length_first_symbol)
        self.symbols_per_block = symbols_per_block

    @property
    def fft_size(self):
        return self._fft_size

    @fft_size.setter
    def fft_size(self, value):
        assert isinstance(value, int) and value>0,\
            "`fft_size` must be a positive integer."
        self._fft_size = int(value)

    @property
    def l_min(self):
        return self._l_min

    @l_min.setter
    def l_min(self, value):
        assert value<=0, "l_min must be nonpositive."
        self._l_min = int(value)

    @property
    def cyclic_prefix_length(self):
        return self._cyclic_prefix_length

    @cyclic_prefix_length.setter
    def cyclic_prefix_length(self, value):
        assert isinstance(value, int) and value >=0,\
            "`cyclic_prefix_length` must be a nonnegative integer."
        self._cyclic_prefix_length = int(value)

    @property
    def cyclic_prefix_length_first_symbol(self):
        if self._cyclic_prefix_length_first_symbol is None:
            return self._cyclic_prefix_length
        else:
            return self._cyclic_prefix_length_first_symbol

    @cyclic_prefix_length_first_symbol.setter
    def cyclic_prefix_length_first_symbol(self, value):
        assert (value is None or isinstance(value, int) and
                value >= self._cyclic_prefix_length),\
            ("`cyclic_prefix_length_first_symbol` must be integer and " +
             "larger or equal to `cyclic_prefix_length`.")
        self._cyclic_prefix_length_first_symbol = value

    @property
    def symbols_per_block(self):
        return self._symbols_per_block

    @symbols_per_block.setter
    def symbols_per_block(self, value):
        assert isinstance(value, int) and  value >= 1,\
            "`symbols_per_block` must be a positive integer."
        self._symbols_per_block = value

    def build(self, input_shape):
        num_samples = input_shape[-1]

        tmp = -2 * PI * tf.cast(self.l_min, tf.float32) \
              / tf.cast(self.fft_size, tf.float32) \
              * tf.range(self.fft_size, dtype=tf.float32)
        self._phase_compensation = tf.exp(tf.complex(0., tmp))

        self._samples_per_block = (self.cyclic_prefix_length_first_symbol +
            (self.symbols_per_block - 1) * self.cyclic_prefix_length +
            self.symbols_per_block * self.fft_size)

        # Compute number of elements that will be truncated and number of
        # symbols for padding
        self._rest = num_samples % self._samples_per_block
        samples_first_symbol = (self.cyclic_prefix_length_first_symbol +
                                self.fft_size)
        samples_other_symbols = (self.cyclic_prefix_length + self.fft_size)
        if self._rest > samples_first_symbol:
            self._rest -= samples_first_symbol
            excess_symbols = self._rest // samples_other_symbols
            self._rest -= excess_symbols * samples_other_symbols
            excess_symbols += 1  # Because of first symbol in block
            self._num_pad_symbols = self.symbols_per_block - excess_symbols
        else:
            self._num_pad_symbols = 0

    def call(self, inputs):
        """Demodulate OFDM waveform onto a resource grid.

        Args:
            inputs (tf.complex64):
                `[...,num_ofdm_symbols*(fft_size+cyclic_prefix_length)]`.

        Returns:
            `tf.complex64` : The demodulated inputs of shape
            `[...,num_ofdm_symbols, fft_size]`.
        """
        batch_dims = tf.shape(inputs)[:-1]

        # Cut last samples that do not fit into an OFDM symbol
        x = inputs if self._rest == 0 else inputs[..., :-self._rest]

        if self._num_pad_symbols > 0:
            pad_samples = self._num_pad_symbols * (self.fft_size +
                                                   self.cyclic_prefix_length)
            padding_shape = tf.concat([batch_dims, [pad_samples]], axis=0)
            padding = tf.zeros(padding_shape, dtype=x.dtype)
            x = tf.concat([x, padding], axis=-1)

        # Reshape input to blocks
        num_blocks = tf.shape(x)[-1] // self._samples_per_block
        new_shape = tf.concat([batch_dims,
                               [num_blocks, self._samples_per_block]], 0)
        x = tf.reshape(x, new_shape)

        # Remove extra cyclic prefix from first symbol
        x = x[...,(self.cyclic_prefix_length_first_symbol -
                   self.cyclic_prefix_length):]

        # Reshape input to separate OFDM symbols
        new_shape = tf.concat([batch_dims,
                               [num_blocks * self.symbols_per_block],
                               [self.fft_size + self.cyclic_prefix_length]], 0)
        x = tf.reshape(x, new_shape)

        # Remove padding
        if self._num_pad_symbols > 0:
            x = x[..., :-self._num_pad_symbols, :]

        # Remove cyclic prefix
        x = x[...,self.cyclic_prefix_length:]

        # Compute FFT
        x = fft(x)

        # Apply phase shift compensation to all subcarriers
        rot = tf.cast(self._phase_compensation, x.dtype)
        rot = expand_to_rank(rot, tf.rank(x), 0)
        x = x * rot

        # Shift DC subcarrier to the middle
        x = fftshift(x, axes=-1)

        return x
